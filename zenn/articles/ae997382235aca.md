---
title: '[Go] 複数モジュールから参照するテーブルのモデルを自動生成'
emoji: '🎃'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['Go']
published: false
---

複数のアプリケーションから呼ば得る汎用パッケージを別 module として切り出すことで、コードの多重管理を防ぐことができました。
また、汎用パッケージに含まれる DB のモデルの生成を自動化しました。個人的に気に入っている仕組みなので紹介したいと思います。

# 背景

- バックエンドには [Hasura GraphQL Engine](https://github.com/hasura/graphql-engine) を採用している関係で、マイグレーション管理は Hasura で行っている
- Hasura のロジック拡張に Remote Schemas を採用 (Go + [99designs/gqlgen](https://github.com/99designs/gqlgen))
  - Hasura の構成ファイルと Remote Schemas は同じリポジトリで管理
  - Remote Schemas では ORM に GORM を使用
  - テーブルのモデルの生成には [smallnest/gen](https://github.com/smallnest/gen) を使用
    - DB のスキーマからいい感じに構造体を生成してくれます

```sh
# 実際のディレクトリ構成とは若干異なりますが、わかりやすさのために簡略化しています
.
├── external   # Hasura の Remote Schemas になっている GraphQL サーバ
│   ├── models # DB モデル。gen で生成。
│   │   ├── hoge_table1.go
│   │   ├── hoge_table2.go
│   │   └── hoge_table3.go
│   # 途中省略
│   ├── go.mod
│   ├── go.sum
│   └── main.go
├── hasura # Hasura の構成ファイル。Go のプロジェクトではない
```

「Hasura / Remote Schemas って何」という方向けに解説記事を貼っておきます。わからなくても本記事の趣旨はつかめると思います

https://qiita.com/maaz118/items/9e198ea91ad8fc624491

https://zenn.dev/msorz/articles/47b47acedb3c5e

# やりたいこと

DB に対しての読み込み・書き込みを伴うバッチ処理を作りたかったです。バッチでは既存の BE と同様、GORM、モデルの生成には gen を使いたいなと思いました。
モデルや DB への接続処理など、`背景` で紹介した GraphQL サーバと一言一句同じコードが生まれてしまうなとは思いつつ、デプロイ先が異なるので、プロジェクトのルートから別でディレクトリを切ってみました。

```sh
.
├── batch-job  # 追加。バッチ処理のソースコード
│   ├── models # DB モデル。gen で生成。
│   │   ├── hoge_table1.go
│   │   ├── hoge_table2.go
│   │   └── hoge_table3.go
│   ├── services
│   # 途中省略
│   ├── go.mod
│   ├── go.sum
│   └── main.go
├── external   # Hasura の Remote Schemas になっている GraphQL サーバ
│   ├── models # DB モデル。gen で生成。
│   │   ├── hoge_table1.go
│   │   ├── hoge_table2.go
│   │   └── hoge_table3.go
│   ├── graph
│   # 途中省略
│   ├── go.mod
│   ├── go.sum
│   └── main.go
├── hasura # Hasura の構成ファイル。Go のプロジェクトではない
```

`batch-job` というディレクトリを切り、そこに新たな module をつくりました。既存の `external` とは完全に独立した module としています。
ご覧の通り `external`、`batch-job` ともに models ディレクトリが切られ、同じファイルが入っています。コードの多重管理が生まれてしまっています。`external` の models も `batch-job` の models も変更頻度・変更理由が全く同じなので、それぞれ別 module で管理することにメリットはありません。**なんとかして、この models を GraphQL サーバからも、バッチ処理からも呼べるように共通化したいです。**
また、models は DB のスキーマに追随するものでなくてはいけません。冒頭で述べたとおり、DB のマイグレーション管理は Hasura が行っているので、**Go の module 側からスキーマの変更を検知する仕組みがほしいです。**

# Go のマルチモジュール

コードの共通化するために、Go のマルチモジュール機能を使うことにしました。共通化したいコードを `shared` という module に切り出しました。

```sh
.
├── docker-compose.yml
├── batch-job  # バッチ処理のソースコード
│   ├── services
│   # 途中省略
│   ├── go.mod
│   ├── go.sum
│   └── main.go
├── external   # Hasura の Remote Schemas になっている GraphQL サーバ
│   ├── graph
│   # 途中省略
│   ├── go.mod
│   ├── go.sum
│   └── main.go
│   ├── metadata
│   ├── migrations
│   └── seeds
└── shared     # 追加。external/batch-job 両方から呼ばれる処理をここへ
    ├── models # DB モデル。gen で生成
    │   ├── hoge_table1.go
    │   ├── hoge_table2.go
    │   └── hoge_table3.go
    ├── go.mod
    ├── go.sum
    └── test   # テスト用の汎用処理 (DBセットアップ・factoryなど)
```

マルチモジュールを使うのにいくつかアプローチがあったのですが、今回は `replace` ディレクティブを使うやり方にしました。

https://go.dev/doc/modules/gomod-ref#replace

> Replaces the content of a module at a specific version (or all versions) with another module version or with a local directory. Go tools will use the replacement path when resolving the dependency.
> 特定のバージョン (またはすべてのバージョン) のモジュールの内容を、別のモジュールのバージョンまたはローカルディレクトリに置き換えます。Go ツールは、依存関係を解決するときに置換されたパスを使用します。

- replace の説明。import するときの名前をつける。その名前をどの path に replace するのかを指定するんだよ
- サンプルコード

# 自動化フロー

- shared のメンテは gen を CI で実行し、差分があったら CI がコケるようにしたい
- CI で実行するためだけのコンテナを作った
- go run にしなかったのは、依存ツールが増え得る可能性を考慮した。
  - (今のとこ増える気配はないから YAGNI だったかも)

# 補足

- go work を使わなかったのはなぜ？
  - external のビルドが go1.15 だったため
  - 下方互換が保たれているはずなので、1.18 に上げることを検討してよかった
- shared をライブラリ化して、別リポジトリで管理すればよかったのでは？
  - DB・Hasura のコンテナと切り離せなかったため同一リポジトリで管理
